// generated by svd2rust 0.23.1 (https://github.com/rust-embedded/svd2rust)

#![no_std]

pub mod generic;
pub mod regs;

use generic::*;
pub use regs::*;

macro_rules! decl_reg {
    ($reg:ident) => {
        paste::paste! {
        #[inline(always)]
        pub fn [<$reg:snake>](&self) -> crate::regs::$reg<I> {
            crate::regs::$reg::new(self.interface)
        }}
    };
}

pub trait Interface<T> {
    type Error;

    /// Write a register.
    ///
    /// # Arguments
    ///
    /// * `addr` - address of the register to write.
    /// * `data` - data to write.
    fn write(&self, addr: u8, data: T) -> Result<(), Self::Error>;

    /// Read a register.
    ///
    /// # Arguments
    ///
    /// * `addr` - address of the register to read.
    fn read(&self, addr: u8) -> Result<T, Self::Error>;
}

/// All the AD9910 registers.
pub struct Registers<'a, I>
where
    I: Interface<u16> + Interface<u32> + Interface<u64>,
{
    interface: &'a I,
}

pub fn regs<I>(interface: &I) -> Registers<'_, I>
where
    I: Interface<u16> + Interface<u32> + Interface<u64>,
{
    Registers::on(interface)
}

impl<'a, I> Registers<'a, I>
where
    I: Interface<u16> + Interface<u32> + Interface<u64>,
{
    pub fn on(interface: &'a I) -> Self {
        Self { interface }
    }

    decl_reg!(Cfr1);
    decl_reg!(Cfr2);
    decl_reg!(Cfr3);
    decl_reg!(AuxDacControl);
    decl_reg!(IoUpdateRate);
    decl_reg!(Ftw);
    decl_reg!(Pow);
    decl_reg!(Asf);
    decl_reg!(MultichipSync);
    decl_reg!(DigitalRampLimit);
    decl_reg!(DigitalRampStepSize);
    decl_reg!(DigitalRampRate);

    decl_reg!(SingleToneProfile0);
    decl_reg!(SingleToneProfile1);
    decl_reg!(SingleToneProfile2);
    decl_reg!(SingleToneProfile3);
    decl_reg!(SingleToneProfile4);
    decl_reg!(SingleToneProfile5);
    decl_reg!(SingleToneProfile6);
    decl_reg!(SingleToneProfile7);

    decl_reg!(RamProfile0);
    decl_reg!(RamProfile1);
    decl_reg!(RamProfile2);
    decl_reg!(RamProfile3);
    decl_reg!(RamProfile4);
    decl_reg!(RamProfile5);
    decl_reg!(RamProfile6);
    decl_reg!(RamProfile7);

    decl_reg!(Ram);
}

#[cfg(test)]
mod tests {
    extern crate std;

    use super::*;
    use crate::regs::cfr2::Cfr2Spec;

    use num_traits::{cast, NumCast};
    use std::cell::RefCell;

    #[derive(Default)]
    struct Device {
        memory: RefCell<[u64; 23]>,
    }

    #[derive(Debug, thiserror::Error)]
    enum Error {
        #[error("Invalid numerical cast.")]
        InvalidCast,
    }

    impl<T: NumCast> Interface<T> for Device {
        type Error = Error;

        fn write(&self, addr: u8, data: T) -> Result<(), Self::Error> {
            let data = cast(data).ok_or(Self::Error::InvalidCast)?;
            self.memory.borrow_mut()[addr as usize] = data;
            Ok(())
        }

        fn read(&self, addr: u8) -> Result<T, Self::Error> {
            cast(self.memory.borrow()[addr as usize]).ok_or(Self::Error::InvalidCast)
        }
    }

    #[test]
    fn demo_reset_regs() {
        let dev = Device::default();
        let regs = Registers::on(&dev);

        // Reset values from datasheet.
        regs.cfr1().reset().unwrap();
        assert_eq!(regs.cfr1().read().unwrap().bits(), 0);

        regs.cfr2().reset().unwrap();
        assert_eq!(regs.cfr2().read().unwrap().bits(), 0x400820);
    }

    #[test]
    fn demo_write_regs() {
        let dev = Device::default();
        let regs = Registers::on(&dev);

        regs.cfr1()
            .write(|w| w.clear_phase_accumulator().set_bit().lsb_first().set_bit())
            .unwrap();

        assert!(regs.cfr1().read().unwrap().clear_phase_accumulator().bit());
        assert!(regs.cfr1().read().unwrap().lsb_first().bit());

        regs.cfr1()
            .write(|w| w.clear_phase_accumulator().set_bit())
            .unwrap();
        assert!(regs.cfr1().read().unwrap().clear_phase_accumulator().bit());

        // 'write' starts from the register's reset value, which is 0 for CFR1
        // so lsb_first is not set.
        assert!(!regs.cfr1().read().unwrap().lsb_first().bit());
    }

    #[test]
    fn demo_modify_regs() {
        let dev = Device::default();
        let regs = Registers::on(&dev);

        regs.cfr2()
            .write(|w| w.digital_ramp_enable().set_bit())
            .unwrap();
        assert_ne!(regs.cfr2().read().unwrap().bits(), Cfr2Spec::reset_value());

        regs.cfr2()
            .modify(|r, w| w.digital_ramp_enable().bit(!r.digital_ramp_enable().bit()))
            .unwrap();
        assert_eq!(regs.cfr2().read().unwrap().bits(), Cfr2Spec::reset_value());
    }

    #[test]
    fn multichip_sync_default() {
        let dev = Device::default();
        let regs = Registers::on(&dev);

        regs.multichip_sync()
            .write(|w| w.sync_receiver_enable().set_bit())
            .unwrap();
        assert_eq!(regs.multichip_sync().read().unwrap().bits(), 0x8000000);
    }

    #[test]
    fn multichip_sync_realistic() {
        use crate::regs::multichip_sync::SyncGeneratorPolarityA::RisingEdge;

        let dev = Device::default();
        let regs = Registers::on(&dev);

        let window = 2;
        let sync_delay = 19;

        regs.multichip_sync()
            .write(|w| unsafe {
                w.sync_validation_delay()
                    .bits(window)
                    .sync_receiver_enable()
                    .set_bit()
                    .sync_generator_enable()
                    .clear_bit()
                    .sync_generator_polarity()
                    .variant(RisingEdge)
                    .sync_state_preset_value()
                    .bits(0)
                    .output_sync_generator_delay()
                    .bits(0)
                    .input_sync_receiver_delay()
                    .bits(sync_delay)
            })
            .unwrap();
        assert_eq!(regs.multichip_sync().read().unwrap().bits(), 0x28000098);
    }
}
